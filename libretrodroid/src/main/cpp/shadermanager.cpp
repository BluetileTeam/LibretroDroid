/*
 *     Copyright (C) 2019  Filippo Scognamiglio
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "shadermanager.h"

namespace libretrodroid {

const std::string ShaderManager::defaultShaderVertex =
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float vFlipY;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform mat4 vViewModel;\n"
    "uniform vec2 textureSize;\n"
    "\n"
    "varying mediump float screenMaskStrength;\n"
    "varying vec2 coords;\n"
    "varying vec2 screenCoords;\n"
    "void main() {\n"
    "  coords = vec2(vCoordinate.x, mix(vCoordinate.y, 1.0 - vCoordinate.y, vFlipY));\n"
    "  screenCoords = coords * textureSize;\n"
    "  screenMaskStrength = smoothstep(2.0, 6.0, screenDensity);\n"
    "  gl_Position = vViewModel * vPosition;\n"
    "}\n";

const std::string ShaderManager::defaultShaderFragment =
    "precision mediump float;\n"
    "uniform lowp sampler2D texture;\n"
    "varying vec2 coords;\n"
    "void main() {\n"
    "  vec4 tex = texture2D(texture, coords);"
    "  gl_FragColor = vec4(tex.rgb, 1.0);\n"
    "}\n";

const std::string ShaderManager::crtShaderFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "uniform lowp sampler2D texture;\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying mediump float screenMaskStrength;\n"
    "\n"
    "#define INTENSITY 0.30\n"
    "#define BRIGHTBOOST 0.30\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 texel = texture2D(texture, coords).rgb;\n"
    "  lowp vec3 pixelHigh = ((1.0 + BRIGHTBOOST) - (0.2 * texel)) * texel;\n"
    "  lowp vec3 pixelLow  = ((1.0 - INTENSITY) + (0.1 * texel)) * texel;\n"
    "\n"
    "  HIGHP vec2 coords = fract(screenCoords) * 2.0 - vec2(1.0);\n"
    "\n"
    "  lowp float mask = 1.0 - abs(coords.y);\n"
    "\n"
    "  gl_FragColor = vec4(mix(texel, mix(pixelLow, pixelHigh, mask), screenMaskStrength), 1.0);\n"
    "}\n";

const std::string ShaderManager::lcdShaderFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform mediump float screenDensity;\n"
    "\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying mediump float screenMaskStrength;\n"
    "\n"
    "#define INTENSITY 0.25\n"
    "#define BRIGHTBOOST 0.25\n"
    "\n"
    "void main() {\n"
    "  mediump vec2 threshold = vec2(1.0 / screenDensity);\n"
    "  mediump vec2 x = fract(screenCoords);\n"
    "  x = 0.5 * (smoothstep(vec2(0.0), threshold, x) + smoothstep(vec2(1.0) - threshold, vec2(1.0), x));\n"
    "  mediump vec2 sharpCoords = (floor(screenCoords) + x) / textureSize;\n"
    "\n"
    "  lowp vec3 texel = texture2D(texture, sharpCoords).rgb;\n"
    "  lowp vec3 pixelHigh = ((1.0 + BRIGHTBOOST) - (0.2 * texel)) * texel;\n"
    "  lowp vec3 pixelLow  = ((1.0 - INTENSITY) + (0.1 * texel)) * texel;\n"
    "\n"
    "  HIGHP vec2 coords = fract(screenCoords) * 2.0 - vec2(1.0);\n"
    "  coords = coords * coords;\n"
    "\n"
    "  lowp float mask = 1.0 - coords.x - coords.y;\n"
    "\n"
    "  gl_FragColor = vec4(mix(texel, mix(pixelLow, pixelHigh, mask), screenMaskStrength), 1.0);\n"
    "}\n";

const std::string ShaderManager::defaultSharpFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "precision mediump float;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform mediump float screenDensity;\n"
    "\n"
    "varying vec2 coords;\n"
    "varying vec2 screenCoords;\n"
    "\n"
    "void main() {\n"
    "  mediump vec2 threshold = vec2(1.0 / screenDensity);\n"
    "  mediump vec2 x = fract(screenCoords);\n"
    "  x = 0.5 * (smoothstep(vec2(0.0), threshold, x) + smoothstep(vec2(1.0) - threshold, vec2(1.0), x));\n"
    "  mediump vec2 sharpCoords = (floor(screenCoords) + x) / textureSize;\n"
    "\n"
    "  vec4 tex = texture2D(texture, sharpCoords);\n"
    "  gl_FragColor = vec4(tex.rgb, 1.0);\n"
    "}\n";

const std::string ShaderManager::cut2UpscaleVertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float vFlipY;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform mat4 vViewModel;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 c1;\n"
    "varying HIGHP vec2 c2;\n"
    "varying HIGHP vec2 c3;\n"
    "varying HIGHP vec2 c4;\n"
    "varying lowp float displaySharpness;\n"
    "\n"
    "void main() {\n"
    "  HIGHP vec2 coords = vec2(vCoordinate.x, mix(vCoordinate.y, 1.0 - vCoordinate.y, vFlipY)) * 1.0001;\n"
    "  screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c1 = (screenCoords) / textureSize;\n"
    "  c2 = (screenCoords + vec2(1.0, 0.0)) / textureSize;\n"
    "  c3 = (screenCoords + vec2(1.0, 1.0)) / textureSize;\n"
    "  c4 = (screenCoords + vec2(0.0, 1.0)) / textureSize;\n"
    "  displaySharpness = SHARPNESS_MAX * (0.5 - 0.5 / max(screenDensity, 1.0));\n"
    "  gl_Position = vViewModel * vPosition;\n"
    "}\n";

const std::unordered_map<std::string, std::string> ShaderManager::cut2UpscaleParams = {
    { "SHARPNESS_BIAS", "1.0" },
    { "SHARPNESS_MAX", "1.0" },
    { "USE_FAST_LUMA", "1" }
};

const std::string ShaderManager::cut2UpscaleFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "#define EPSILON 0.01\n"
    "\n"
    "precision mediump float;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform mediump float screenDensity;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 c1;\n"
    "varying HIGHP vec2 c2;\n"
    "varying HIGHP vec2 c3;\n"
    "varying HIGHP vec2 c4;\n"
    "varying lowp float displaySharpness;\n"
    "\n"
    "lowp float fastLuma(lowp vec3 v) {\n"
    "  return v.g;\n"
    "}\n"
    "#if USE_FAST_LUMA\n"
    "lowp float luma(lowp vec3 v) {\n"
    "  return fastLuma(v);\n"
    "}\n"
    "#else\n"
    "lowp float luma(lowp vec3 v) {\n"
    "  return dot(v, vec3(0.299, 0.587, 0.114));\n"
    "}\n"
    "#endif\n"
    "\n"
    "lowp float linearStep(lowp float edge0, lowp float edge1, lowp float t) {\n"
    "  return clamp((t - edge0) / (edge1 - edge0), 0.0, 1.0);\n"
    "}\n"
    "lowp float sharpSmooth(lowp float t, lowp float sharpness) {\n"
    "  return linearStep(sharpness, 1.0 - sharpness, t);\n"
    "}\n"
    "lowp vec3 blend(lowp vec3 a, lowp vec3 b, lowp float t) {\n"
    "  lowp float lumaDiff = abs(fastLuma(a) - fastLuma(b));\n"
    "  lowp float sharpness = displaySharpness * min(lumaDiff * SHARPNESS_BIAS, 1.0);\n"
    "  return mix(a, b, sharpSmooth(t, sharpness));\n"
    "}\n"
    "lowp vec3 interpolate(\n"
    "  lowp vec3 a,\n"
    "  lowp vec3 b,\n"
    "  lowp vec3 c,\n"
    "  lowp vec3 d,\n"
    "  lowp float tana,\n"
    "  lowp vec2 p\n"
    ") {\n"
    "  bool leftTriangle = p.x < tana * (1.0 - p.y);\n"
    "  bool rightTriangle = p.x > 1.0 - tana * p.y;\n"
    "  lowp vec3 p0 = rightTriangle ? b : a;\n"
    "  lowp vec3 p1 = rightTriangle ? d : b;\n"
    "  lowp vec3 p2 = leftTriangle ? a : c;\n"
    "  lowp vec3 p3 = leftTriangle ? c : d;\n"
    "  lowp float x0 = rightTriangle ? p.y - (1.0 - p.x) / tana : p.x + p.y * tana;\n"
    "  lowp float x1 = leftTriangle ? p.y + p.x / tana : p.x - (1.0 - p.y) * tana;\n"
    "  lowp float y = \n"
    "    leftTriangle ? p.y / x1 :\n"
    "    rightTriangle ? (p.y - x0) / (1.0 - x0) :\n"
    "    p.y;\n"
    "  return blend(blend(p0, p1, x0), blend(p2, p3, x1), y);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 t1 = texture2D(texture, c1).rgb;\n"
    "  lowp vec3 t2 = texture2D(texture, c2).rgb;\n"
    "  lowp vec3 t3 = texture2D(texture, c3).rgb;\n"
    "  lowp vec3 t4 = texture2D(texture, c4).rgb;\n"
    "\n"
    "  lowp float l1 = luma(t1);\n"
    "  lowp float l2 = luma(t2);\n"
    "  lowp float l3 = luma(t3);\n"
    "  lowp float l4 = luma(t4);\n"
    "\n"
    "  lowp vec2 gradient = vec2(l1 - l2 - l3 + l4, l1 + l2 - l3 - l4);\n"
    "  lowp vec2 absGradient = abs(gradient);\n"
    "\n"
    "  bool invertedAngle = absGradient.y > absGradient.x + EPSILON;\n"
    "  bool negativeAngle = (gradient.x * gradient.y) < -EPSILON * EPSILON;\n"
    "\n"
    "  lowp float minGradient = min(absGradient.x, absGradient.y);\n"
    "  lowp float maxGradient = max(absGradient.x, absGradient.y);\n"
    "  lowp float atana = step(maxGradient + EPSILON, minGradient * 2.0);\n"
    "\n"
    "  lowp vec2 pxCoords = fract(screenCoords);\n"
    "\n"
    "  lowp vec3 a = t1;\n"
    "  lowp vec3 b = invertedAngle ? t4 : t2;\n"
    "  lowp vec3 c = invertedAngle ? t2 : t4;\n"
    "  lowp vec3 d = t3;\n"
    "  pxCoords = invertedAngle ? pxCoords.yx : pxCoords;\n"
    "\n"
    "  lowp vec3 final = interpolate(\n"
    "    negativeAngle ? b : a,\n"
    "    negativeAngle ? a : b,\n"
    "    negativeAngle ? d : c,\n"
    "    negativeAngle ? c : d,\n"
    "    atana,\n"
    "    negativeAngle ? vec2(1.0 - pxCoords.x, pxCoords.y) : pxCoords\n"
    "  );\n"
    "\n"
    "  gl_FragColor = vec4(final, 1.0);\n"
    "}\n";

const std::unordered_map<std::string, std::string> ShaderManager::cutUpscaleParams = {
    { "USE_DYNAMIC_SHARPNESS", "1" },
    { "USE_SHARPENING_BIAS", "1" },
    { "DYNAMIC_SHARPNESS_MIN", "0.10" },
    { "DYNAMIC_SHARPNESS_MAX", "0.30" },
    { "STATIC_SHARPNESS", "0.5" },
    { "USE_FAST_LUMA", "1" },
    { "TRIANGULATION_THRESHOLD", "4.0" },
};

const std::string ShaderManager::cutUpscaleVertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float vFlipY;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform mat4 vViewModel;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 c1;\n"
    "varying HIGHP vec2 c2;\n"
    "varying HIGHP vec2 c3;\n"
    "varying HIGHP vec2 c4;\n"
    "\n"
    "void main() {\n"
    "  HIGHP vec2 coords = vec2(vCoordinate.x, mix(vCoordinate.y, 1.0 - vCoordinate.y, vFlipY)) * 1.0001;\n"
    "  screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c1 = (screenCoords) / textureSize;\n"
    "  c2 = (screenCoords + vec2(1.0, 0.0)) / textureSize;\n"
    "  c3 = (screenCoords + vec2(1.0, 1.0)) / textureSize;\n"
    "  c4 = (screenCoords + vec2(0.0, 1.0)) / textureSize;\n"
    "  gl_Position = vViewModel * vPosition;\n"
    "}\n";

const std::string ShaderManager::cutUpscaleFragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "precision mediump float;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform mediump float screenDensity;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 c1;\n"
    "varying HIGHP vec2 c2;\n"
    "varying HIGHP vec2 c3;\n"
    "varying HIGHP vec2 c4;\n"
    "\n"
    "#if USE_FAST_LUMA\n"
    "lowp float luma(lowp vec3 v) {\n"
    "  return v.g;\n"
    "}\n"
    "#else\n"
    "lowp float luma(lowp vec3 v) {\n"
    "  return dot(v, vec3(0.299, 0.587, 0.114));\n"
    "}\n"
    "#endif\n"
    "lowp float linearStep(lowp float edge0, lowp float edge1, lowp float t) {\n"
    "  return clamp((t - edge0) / (edge1 - edge0), 0.0, 1.0);\n"
    "}\n"
    "lowp float sharpSmooth(lowp float t, lowp float sharpness) {\n"
    "  return linearStep(sharpness, 1.0 - sharpness, t);\n"
    "}\n"
    "lowp vec3 quadBilinear(lowp vec3 a, lowp vec3 b, lowp vec3 c, lowp vec3 d, lowp vec2 p, lowp float sharpness) {\n"
    "  lowp float x = sharpSmooth(p.x, sharpness);\n"
    "  lowp float y = sharpSmooth(p.y, sharpness);\n"
    "  return mix(mix(a, b, x), mix(c, d, x), y);\n"
    "}\n"
    "// Fast computation of barycentric coordinates only in the sub-triangle 1 2 4\n"
    "lowp vec3 fastBarycentric(lowp vec2 p, lowp float sharpness) {\n"
    "  lowp float l0 = sharpSmooth(1.0 - p.x - p.y, sharpness);\n"
    "  lowp float l1 = sharpSmooth(p.x, sharpness);\n"
    "  return vec3(l0, l1, 1.0 - l0 - l1);\n"
    "}\n"
    "\n"
    "lowp vec3 triangleInterpolate(lowp vec3 t1, lowp vec3 t2, lowp vec3 t3, lowp vec3 t4, lowp vec2 c, lowp float sharpness) {\n"
    "  // Alter colors and coordinates to compute the other triangle.\n"
    "  bool altTriangle = 1.0 - c.x < c.y;\n"
    "  lowp vec3 cornerColor = altTriangle ? t3 : t1;\n"
    "  lowp vec2 triangleCoords = altTriangle ? vec2(1.0 - c.y, 1.0 - c.x) : c;\n"
    "  lowp vec3 weights = fastBarycentric(triangleCoords, sharpness);\n"
    "  return weights.x * cornerColor + weights.y * t2 + weights.z * t4;\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 t1 = texture2D(texture, c1).rgb;\n"
    "  lowp vec3 t2 = texture2D(texture, c2).rgb;\n"
    "  lowp vec3 t3 = texture2D(texture, c3).rgb;\n"
    "  lowp vec3 t4 = texture2D(texture, c4).rgb;\n"
    "\n"
    "  lowp float l1 = luma(t1);\n"
    "  lowp float l2 = luma(t2);\n"
    "  lowp float l3 = luma(t3);\n"
    "  lowp float l4 = luma(t4);\n"
    "\n"
    "#if USE_DYNAMIC_SHARPNESS\n"
    "  lowp float lmax = max(max(l1, l2), max(l3, l4));\n"
    "  lowp float lmin = min(min(l1, l2), min(l3, l4));\n"
    "  lowp float contrast = (lmax - lmin) / (lmax + lmin + 0.05);\n"
    "#if USE_SHARPENING_BIAS\n"
    "  contrast = sqrt(contrast);\n"
    "#endif\n"
    "  lowp float sharpness = mix(DYNAMIC_SHARPNESS_MIN, DYNAMIC_SHARPNESS_MAX, contrast);\n"
    "#else\n"
    "  const lowp float sharpness = STATIC_SHARPNESS;\n"
    "#endif\n"
    "\n"
    "  lowp vec2 pxCoords = fract(screenCoords);\n"
    "\n"
    "  lowp float diagonal1Strength = abs(l1 - l3);\n"
    "  lowp float diagonal2Strength = abs(l2 - l4);\n"
    "\n"
    "  // Alter colors and coordinates to compute the other triangulation.\n"
    "  bool altTriangulation = diagonal1Strength < diagonal2Strength;\n"
    "\n"
    "  lowp vec3 cd = triangleInterpolate(\n"
    "    altTriangulation ? t2 : t1,\n"
    "    altTriangulation ? t3 : t2,\n"
    "    altTriangulation ? t4 : t3,\n"
    "    altTriangulation ? t1 : t4,\n"
    "    altTriangulation ? vec2(pxCoords.y, 1.0 - pxCoords.x) : pxCoords,\n"
    "    sharpness\n"
    "  );\n"
    "\n"
    "  lowp float minDiagonal = min(diagonal1Strength, diagonal2Strength);\n"
    "  lowp float maxDiagonal = max(diagonal1Strength, diagonal2Strength);\n"
    "  bool diagonal = minDiagonal * TRIANGULATION_THRESHOLD + 0.05 < maxDiagonal;\n"
    "\n"
    "  lowp vec3 final = diagonal ? cd : quadBilinear(t1, t2, t4, t3, pxCoords, sharpness);\n"
    "\n"
    "  gl_FragColor = vec4(final, 1.0);\n"
    "}\n";

const std::unordered_map<std::string, std::string> ShaderManager::cut3UpscaleParams = {
    { "SHARPNESS_BIAS", "2.0" },
    { "SHARPNESS_MAX", "1.0" },
    { "SHARPNESS_MIN", "0.0" },
    { "USE_FAST_LUMA", "0" }
};

const std::string ShaderManager::cut3UpscalePass0Vertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform mat4 vViewModel;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform mediump float vFlipY;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 c1;\n"
    "varying HIGHP vec2 c2;\n"
    "varying HIGHP vec2 c4;\n"
    "varying HIGHP vec2 c5;\n"
    "varying HIGHP vec2 c6;\n"
    "varying HIGHP vec2 c7;\n"
    "varying HIGHP vec2 c8;\n"
    "varying HIGHP vec2 c9;\n"
    "varying HIGHP vec2 c10;\n"
    "varying HIGHP vec2 c11;\n"
    "varying HIGHP vec2 c13;\n"
    "varying HIGHP vec2 c14;\n"
    "\n"
    "void main() {\n"
    "  coords = vec2(vCoordinate.x, mix(vCoordinate.y, 1.0 - vCoordinate.y, vFlipY)) * 1.0001;\n"
    "  screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c1 = (screenCoords + vec2(+0.0, -1.0)) / textureSize;\n"
    "  c2 = (screenCoords + vec2(+1.0, -1.0)) / textureSize;\n"
    "  c4 = (screenCoords + vec2(-1.0, +0.0)) / textureSize;\n"
    "  c5 = (screenCoords + vec2(+0.0, +0.0)) / textureSize;\n"
    "  c6 = (screenCoords + vec2(+1.0, +0.0)) / textureSize;\n"
    "  c7 = (screenCoords + vec2(+2.0, +0.0)) / textureSize;\n"
    "  c8 = (screenCoords + vec2(-1.0, +1.0)) / textureSize;\n"
    "  c9 = (screenCoords + vec2(+0.0, +1.0)) / textureSize;\n"
    "  c10 = (screenCoords + vec2(+1.0, +1.0)) / textureSize;\n"
    "  c11 = (screenCoords + vec2(+2.0, +1.0)) / textureSize;\n"
    "  c13 = (screenCoords + vec2(+0.0, +2.0)) / textureSize;\n"
    "  c14 = (screenCoords + vec2(+1.0, +2.0)) / textureSize;\n"
    "  gl_Position = vViewModel * vPosition;\n"
    "}\n";

const std::string ShaderManager::cut3UpscalePass0Fragment =
   "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
   "#define HIGHP highp\n"
   "#else\n"
   "#define HIGHP mediump\n"
   "precision mediump float;\n"
   "#endif\n"
   "#define EPSILON 0.01\n"
   "\n"
   "precision mediump float;\n"
   "uniform lowp sampler2D texture;\n"
   "uniform HIGHP vec2 textureSize;\n"
   "uniform mediump float screenDensity;\n"
   "\n"
   "#define MIN_SADDLE 0.10\n"
   "#define MIN_EDGE_1 0.02\n"
   "#define EDGE_1_THRESHOLD 2.0\n"
   "#define MIN_EDGE_2 0.02\n"
   "#define EDGE_2_THRESHOLD 3.0\n"
   "\n"
   "varying HIGHP vec2 screenCoords;\n"
   "varying HIGHP vec2 coords;\n"
   "varying HIGHP vec2 c1;\n"
   "varying HIGHP vec2 c2;\n"
   "varying HIGHP vec2 c4;\n"
   "varying HIGHP vec2 c5;\n"
   "varying HIGHP vec2 c6;\n"
   "varying HIGHP vec2 c7;\n"
   "varying HIGHP vec2 c8;\n"
   "varying HIGHP vec2 c9;\n"
   "varying HIGHP vec2 c10;\n"
   "varying HIGHP vec2 c11;\n"
   "varying HIGHP vec2 c13;\n"
   "varying HIGHP vec2 c14;\n"
   "\n"
   "lowp float fastLuma(lowp vec3 v) {\n"
   "  return v.g;\n"
   "}\n"
   "#if USE_FAST_LUMA\n"
   "lowp float luma(lowp vec3 v) {\n"
   "  return fastLuma(v);\n"
   "}\n"
   "#else\n"
   "lowp float luma(lowp vec3 v) {\n"
   "  return dot(v, vec3(0.299, 0.587, 0.114));\n"
   "}\n"
   "#endif\n"
   "\n"
   "// Edge detection\n"
   "lowp float hasDiagonal(lowp float d1, lowp float d2, lowp float d3, lowp float d4) {\n"
   "  lowp float diff1 = abs(d1 - d2);\n"
   "  lowp float diff2 = abs(d3 - d4);\n"
   "  return step(EDGE_1_THRESHOLD * diff1 + MIN_EDGE_1, diff2);\n"
   "}\n"
   "lowp vec2 minMax(lowp vec2 v) {\n"
   "  return vec2(min(v.x, v.y), max(v.x, v.y));\n"
   "}\n"
   "lowp float maxDelta(lowp vec2 mm) {\n"
   "  return mm.y - mm.x;\n"
   "}\n"
   "lowp float maxDelta(lowp vec2 mm1, lowp vec2 mm2) {\n"
   "  return max(mm1.y, mm2.y) - min(mm1.x, mm2.x);\n"
   "}\n"
   "lowp float minDelta(lowp vec2 mm1, lowp vec2 mm2) {\n"
   "  return abs(min(mm1.y, mm2.y) - max(mm1.x, mm2.x));\n"
   "}\n"
   "lowp float hasDiagonal(lowp vec2 left, lowp vec2 main, lowp vec2 right) {\n"
   "  lowp vec2 mmLeft = minMax(left);\n"
   "  lowp vec2 mmMain = minMax(main);\n"
   "  lowp vec2 mmRight = minMax(right);\n"
   "  lowp float diff1 = min(maxDelta(mmMain, mmLeft), maxDelta(mmMain, mmRight));\n"
   "  lowp float diff2 = minDelta(mmLeft, mmRight);\n"
   "  return step(EDGE_2_THRESHOLD * diff1 + MIN_EDGE_2, diff2);\n"
   "}\n"
   "bool isSaddle(lowp float d1, lowp float d2, lowp float d3, lowp float d4) {\n"
   "  return abs(d1 - d2) < MIN_EDGE_1 && abs(d3 - d4) < MIN_EDGE_1;\n"
   "}\n"
   "// TODO FILIPPO... It would be very cool to pack 4 values here instead of three\n"
   "lowp float pack(lowp vec3 values) {\n"
   "  return dot(values, vec3(4.0, 16.0, 64.0));\n"
   "}\n"
   "\n"
   "void main() {\n"
   "  lowp vec3 t1 = texture2D(texture, c1).rgb;\n"
   "  lowp vec3 t2 = texture2D(texture, c2).rgb;\n"
   "  lowp vec3 t4 = texture2D(texture, c4).rgb;\n"
   "  lowp vec3 t5 = texture2D(texture, c5).rgb;\n"
   "  lowp vec3 t6 = texture2D(texture, c6).rgb;\n"
   "  lowp vec3 t7 = texture2D(texture, c7).rgb;\n"
   "  lowp vec3 t8 = texture2D(texture, c8).rgb;\n"
   "  lowp vec3 t9 = texture2D(texture, c9).rgb;\n"
   "  lowp vec3 t10 = texture2D(texture, c10).rgb;\n"
   "  lowp vec3 t11 = texture2D(texture, c11).rgb;\n"
   "  lowp vec3 t13 = texture2D(texture, c13).rgb;\n"
   "  lowp vec3 t14 = texture2D(texture, c14).rgb;\n"
   "\n"
   "  lowp float l1 = luma(t1);\n"
   "  lowp float l2 = luma(t2);\n"
   "  lowp float l4 = luma(t4);\n"
   "  lowp float l5 = luma(t5);\n"
   "  lowp float l6 = luma(t6);\n"
   "  lowp float l7 = luma(t7);\n"
   "  lowp float l8 = luma(t8);\n"
   "  lowp float l9 = luma(t9);\n"
   "  lowp float l10 = luma(t10);\n"
   "  lowp float l11 = luma(t11);\n"
   "  lowp float l13 = luma(t13);\n"
   "  lowp float l14 = luma(t14);\n"
   "\n"
   "  lowp float d05_10 = hasDiagonal(l5, l10, l6, l9);\n"
   "  lowp float d06_09 = hasDiagonal(l6, l9, l5, l10);\n"
   "\n"
   "  // Saddle fix\n"
   "  if (isSaddle(l5, l10, l6, l9)) {\n"
   "    lowp float average = (l1 + l2 + l4 + l7 + l8 + l11 + l13 + l14) / 8.0;\n"
   "    lowp float diff1 = abs(mix(l5, l10, 0.5) - average);\n"
   "    lowp float diff2 = abs(mix(l6, l9, 0.5) - average);\n"
   "    d05_10 = step(diff2 + MIN_SADDLE, diff1);\n"
   "    d06_09 = step(diff1 + MIN_SADDLE, diff2);\n"
   "  }\n"
   "\n"
   "  // Vertical diagonals\n"
   "  lowp float d01_10 = hasDiagonal(vec2(l5, l9), vec2(l1, l10), vec2(l2, l6));\n"
   "  lowp float d02_09 = hasDiagonal(vec2(l1, l5), vec2(l2, l9), vec2(l6, l10));\n"
   "  lowp float d05_14 = hasDiagonal(vec2(l9, l13), vec2(l5, l14), vec2(l6, l10));\n"
   "  lowp float d06_13 = hasDiagonal(vec2(l5, l9), vec2(l6, l13), vec2(l10, l14));\n"
   "\n"
   "  // Horizontal diagonals\n"
   "  lowp float d04_10 = hasDiagonal(vec2(l8, l9), vec2(l4, l10), vec2(l5, l6));\n"
   "  lowp float d06_08 = hasDiagonal(vec2(l9, l10), vec2(l6, l8), vec2(l4, l5));\n"
   "  lowp float d05_11 = hasDiagonal(vec2(l9, l10), vec2(l5, l11), vec2(l6, l7));\n"
   "  lowp float d07_09 = hasDiagonal(vec2(l10, l11), vec2(l7, l9), vec2(l5, l6));\n"
   "\n"
   "  lowp float originalDiagonal = max(d05_10, d06_09);\n"
   "  // Main diagonals again\n"
   "  d05_10 = clamp(d05_10 + d01_10 + d05_14 + d05_11 + d04_10, 0.0, 1.0);\n"
   "  d06_09 = clamp(d06_09 + d02_09 + d06_13 + d06_08 + d07_09, 0.0, 1.0);\n"
   "\n"
   "  lowp vec4 final = vec4(0.0);\n"
   "  if (d05_10 > 0.0 && d06_09 < EPSILON) {\n"
   "    final.x = pack(vec3(1.0, 0.0, 0.0));\n"
   "    final.y = pack(vec3(d01_10, d05_14, originalDiagonal));\n"
   "    final.z = pack(vec3(d04_10, d05_11, d05_11));\n"
   "  } else if (d06_09 > 0.0 && d05_10 < EPSILON) {\n"
   "    final.x = pack(vec3(0.0, 1.0, 0.0));\n"
   "    final.y = pack(vec3(d02_09, d06_13, originalDiagonal));\n"
   "    final.z = pack(vec3(d06_08, d07_09, d06_08));\n"
   "  } else {\n"
   "    final.x = pack(vec3(0.0, 0.0, 1.0));\n"
   "    final.y = pack(vec3(min(d04_10, d07_09), min(d06_08, d05_11), 0.0));\n"
   "    final.z = pack(vec3(min(d01_10, d06_13), min(d02_09, d05_14), 0.0));\n"
   "  }\n"
   "  gl_FragColor = final / 255.0;\n"
   "}";

const std::string ShaderManager::cut3UpscalePass1Vertex =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "attribute vec4 vPosition;\n"
    "attribute vec2 vCoordinate;\n"
    "uniform mediump float screenDensity;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform mat4 vViewModel;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform mediump float vFlipY;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 passCoords;\n"
    "varying HIGHP vec2 c5;\n"
    "varying HIGHP vec2 c6;\n"
    "varying HIGHP vec2 c9;\n"
    "varying HIGHP vec2 c10;\n"
    "varying lowp float deltaSharpness;\n"
    "\n"
    "void main() {\n"
    "  coords = vec2(vCoordinate.x, mix(vCoordinate.y, 1.0 - vCoordinate.y, vFlipY)) * 1.0001;\n"
    "  screenCoords = coords * textureSize - vec2(0.5);\n"
    "  c5 = (screenCoords + vec2(+0.0, +0.0)) / textureSize;\n"
    "  c6 = (screenCoords + vec2(+1.0, +0.0)) / textureSize;\n"
    "  c9 = (screenCoords + vec2(+0.0, +1.0)) / textureSize;\n"
    "  c10 = (screenCoords + vec2(+1.0, +1.0)) / textureSize;\n"
    "  passCoords = vec2(c5.x, mix(c5.y, 1.0 - c5.y, vFlipY));\n"

    "  deltaSharpness = max(0.0, SHARPNESS_MAX * (0.5 - 0.5 / max(screenDensity, 1.0)) - 0.5 * SHARPNESS_MIN);\n"
    "  gl_Position = vViewModel * vPosition;\n"
    "}\n";

const std::string ShaderManager::cut3UpscalePass1Fragment =
    "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
    "#define HIGHP highp\n"
    "#else\n"
    "#define HIGHP mediump\n"
    "precision mediump float;\n"
    "#endif\n"
    "#define EPSILON 0.01\n"
    "\n"
    "precision mediump float;\n"
    "uniform lowp sampler2D texture;\n"
    "uniform HIGHP vec2 textureSize;\n"
    "uniform lowp sampler2D previousPass;\n"
    "uniform mediump float screenDensity;\n"
    "uniform mediump float vFlipY;\n"
    "\n"
    "varying HIGHP vec2 screenCoords;\n"
    "varying HIGHP vec2 coords;\n"
    "varying HIGHP vec2 passCoords;\n"
    "varying HIGHP vec2 c5;\n"
    "varying HIGHP vec2 c6;\n"
    "varying HIGHP vec2 c9;\n"
    "varying HIGHP vec2 c10;\n"
    "varying lowp float deltaSharpness;\n"
    "\n"
    "lowp float fastLuma(lowp vec3 v) {\n"
    "  return v.g;\n"
    "}\n"
    "#if USE_FAST_LUMA\n"
    "lowp float luma(lowp vec3 v) {\n"
    "  return fastLuma(v);\n"
    "}\n"
    "#else\n"
    "lowp float luma(lowp vec3 v) {\n"
    "  return dot(v, vec3(0.299, 0.587, 0.114));\n"
    "}\n"
    "#endif\n"
    "\n"
    "lowp float linearStep(lowp float edge0, lowp float edge1, lowp float t) {\n"
    "  return clamp((t - edge0) / (edge1 - edge0), 0.0, 1.0);\n"
    "}\n"
    "lowp float sharpSmooth(lowp float t, lowp float sharpness) {\n"
    "  return linearStep(sharpness, 1.0 - sharpness, t);\n"
    "}\n"
    "lowp float sharpness(lowp float l1, lowp float l2) {\n"
    "  lowp float lumaDiff = abs(l1 - l2);\n"
    "  lowp float sharpness = 0.5 * SHARPNESS_MIN + deltaSharpness * min(lumaDiff * SHARPNESS_BIAS, 1.0);\n"
    "  return sharpness;\n"
    "}\n"
    "lowp float sharpness(lowp vec3 c1, lowp vec3 c2) {\n"
    "  return sharpness(fastLuma(c1), fastLuma(c2));\n"
    "}\n"
    "lowp vec3 blend(lowp vec3 a, lowp vec3 b, lowp float t) {\n"
    "  return mix(a, b, sharpSmooth(t, sharpness(a, b)));\n"
    "}\n"
    "lowp vec3 unpack(lowp float values) {\n"
    "  return vec3(floor(mod(values / 4.0, 4.0)), floor(mod(values / 16.0, 4.0)), floor(mod(values / 64.0, 4.0)));\n"
    "}\n"
    "lowp float intersection(lowp vec2 a, lowp vec2 b, lowp vec2 c, lowp vec2 d) {\n"
    "  lowp float ydc = d.y - c.y;\n"
    "  lowp float xdc = d.x - c.x;\n"
    "  lowp float num = (a.y - c.y) * xdc - (a.x - c.x) * ydc;\n"
    "  lowp float denom = (b.x - a.x) * ydc - (b.y - a.y) * xdc;\n"
    "  return num / denom;\n"
    "}\n"
    "lowp vec3 barycentric(lowp vec2 ps[3], lowp vec2 p) {\n"
    "  lowp float ri1 = intersection(ps[0], ps[1], p + ps[1] - ps[2], p + ps[2] - ps[1]);\n"
    "  lowp vec2 ai1 = mix(ps[0], ps[1], ri1);\n"
    "\n"
    "  lowp float ri2 = intersection(ps[0], ps[2], p + ps[1] - ps[2], p + ps[2] - ps[1]);\n"
    "  lowp vec2 ai2 = mix(ps[0], ps[2], ri2);\n"
    "\n"
    "  return vec3(ri1, ri2, distance(p, ai1) / (distance(p, ai1) + distance(p, ai2)));\n"
    "}\n"
    "\n"
    "void triangleInterpolate(lowp vec3 t5, lowp vec3 t6, lowp vec3 t9, lowp vec3 t10, lowp vec3 flags[3], lowp vec2 pxCoords, out lowp vec3 outColors[4], out lowp vec3 weights) {\n"
    "  lowp vec2 pCoords[3];\n"
    "  lowp vec3 pColors[3];\n"
    "\n"
    "  lowp vec3 a1 = t5;\n"
    "  lowp vec3 b1 = t6;\n"
    "  lowp vec3 c1 = t9;\n"
    "  lowp vec3 d1 = t10;\n"
    "\n"
    "  bool du = flags[1].x > 0.0;\n"
    "  bool dd = flags[1].y > 0.0;\n"
    "  bool dl = flags[2].x > 0.0;\n"
    "  bool dr = flags[2].y > 0.0;\n"
    "\n"
    "  bool negative = flags[0].y > 0.0;\n"
    "\n"
    "  if (negative) {\n"
    "    pxCoords = vec2(1.0 - pxCoords.x, pxCoords.y);\n"
    "    a1 = t6; b1 = t5; c1 = t10; d1 = t9;\n"
    "    bool tmp = dl; dl = dr; dr = tmp; // TODO FILIPPO Maybe move the vertex shader\n"
    "  }\n"
    "\n"
    "  lowp vec3 a = a1;\n"
    "  lowp vec3 b = b1;\n"
    "  lowp vec3 c = c1;\n"
    "  lowp vec3 d = d1;\n"
    "\n"
    "  bool inverted = pxCoords.x > pxCoords.y;\n"
    "\n"
    "  if (inverted) {\n"
    "    pxCoords = vec2(pxCoords.y, pxCoords.x);\n"
    "    b = c1; c = b1;\n"
    "    dd = dr; dl = du;\n"
    "  }\n"
    "\n"
    "  if (dd && dl) {\n"
    "    if (pxCoords.y > 0.5 + pxCoords.x) {\n"
    "      pCoords[0] = vec2(0.0, 0.5); pCoords[1] = vec2(0.0, 1.0); pCoords[2] = vec2(0.5, 1.0);\n"
    "      pColors[0] = d; pColors[1] = c; pColors[2] = a;\n"
    "    } else {\n"
    "      pCoords[0] = vec2(0.0, 0.0); pCoords[1] = vec2(0.0, 1.0); pCoords[2] = vec2(1.0, 1.0);\n"
    "      pColors[0] = a; pColors[1] = a; pColors[2] = d; // TODO FILIPPO... La a e' una porcata\n"
    "    }\n"
    "  } else if (dd) {\n"
    "    if (pxCoords.y > 2.0 * pxCoords.x) {\n"
    "      pCoords[0] = vec2(0.0, 1.0); pCoords[1] = vec2(0.0, 0.0); pCoords[2] = vec2(0.5, 1.0);\n"
    "      pColors[0] = c; pColors[1] = a; pColors[2] = a;\n"
    "    } else {\n"
    "      pCoords[0] = vec2(1.0, 1.0); pCoords[1] = vec2(0.0, 0.0); pCoords[2] = vec2(0.5, 1.0);\n"
    "      pColors[0] = d; pColors[1] = a; pColors[2] = a;\n"
    "    }\n"
    "  } else if (dl) {\n"
    "    if (pxCoords.y > 0.5 * pxCoords.x + 0.5) {\n"
    "      pCoords[0] = vec2(0.0, 1.0); pCoords[1] = vec2(0.0, 0.5); pCoords[2] = vec2(1.0, 1.0);\n"
    "      pColors[0] = c; pColors[1] = d; pColors[2] = d;\n"
    "    } else {\n"
    "      pCoords[0] = vec2(0.0, 0.0); pCoords[1] = vec2(0.0, 0.5); pCoords[2] = vec2(1.0, 1.0);\n"
    "      pColors[0] = a; pColors[1] = d; pColors[2] = d;\n"
    "    }\n"
    "  } else {\n"
    "    if (flags[1].z > 0.0) { // This interpolation only works with triangles which where originally half a square\n"
    "      pCoords[0] = vec2(0.0, 1.0); pCoords[1] = vec2(0.0, 0.0); pCoords[2] = vec2(1.0, 1.0);\n"
    "      pColors[0] = c; pColors[1] = a; pColors[2] = d;\n"
    "    } else if (flags[1].x > 0.0) {\n"
    "      pCoords[0] = vec2(1.0, 1.0); pCoords[1] = vec2(0.0, 1.0); pCoords[2] = vec2(0.0, 0.0);\n"
    "      pColors[0] = d; pColors[1] = c; pColors[2] = a;\n"
    "    } else if (flags[1].y > 0.0) {\n"
    "      pCoords[0] = vec2(0.0, 0.0); pCoords[1] = vec2(1.0, 1.0); pCoords[2] = vec2(0.0, 1.0); \n"
    "      pColors[0] = a; pColors[1] = d; pColors[2] = c;\n"
    "    } else if (flags[2].z > 0.0) {\n"
    "      pCoords[0] = vec2(0.0, 0.0); pCoords[1] = vec2(1.0, 1.0); pCoords[2] = vec2(0.0, 1.0); \n"
    "      pColors[0] = a; pColors[1] = d; pColors[2] = c;\n"
    "    } else {\n"
    "      pCoords[0] = vec2(1.0, 1.0); pCoords[1] = vec2(0.0, 1.0); pCoords[2] = vec2(0.0, 0.0);\n"
    "      pColors[0] = d; pColors[1] = c; pColors[2] = a;\n"
    "    }\n"
    "  }\n"
    "\n"
    "  outColors[0] = pColors[0]; outColors[1] = pColors[1]; outColors[2] = pColors[0]; outColors[3] = pColors[2];\n"
    "  weights = barycentric(pCoords, pxCoords);\n"
    "}\n"
    "void swap(inout lowp vec3 a, inout lowp vec3 b) {\n"
    "  lowp vec3 tmp = a;\n"
    "  a = b;\n"
    "  b = tmp;\n"
    "}\n"
    "void quadInterpolate(lowp vec3 t5, lowp vec3 t6, lowp vec3 t9, lowp vec3 t10, lowp vec3 flags[3], lowp vec2 pxCoords, out lowp vec3 outColors[4], out lowp vec3 outWeights) {\n"
    "  lowp vec2 finalCoords;\n"
    "\n"
    "  bool h0 = flags[1].x > 0.0;\n"
    "  bool h1 = flags[1].y > 0.0;\n"
    "\n"
    "  bool v0 = flags[2].x > 0.0;\n"
    "  bool v1 = flags[2].y > 0.0;\n"
    "\n"
    "  lowp vec3 a = t5;\n"
    "  lowp vec3 b = t6;\n"
    "  lowp vec3 c = t9;\n"
    "  lowp vec3 d = t10;\n"
    "\n"
    "  if (v0 || v1) {\n"
    "    h0 = v0;\n"
    "    h1 = v1;\n"
    "    a = t9; b = t5; c = t10; d = t6;\n"
    "    pxCoords = vec2(1.0 - pxCoords.y, pxCoords.x);\n"
    "  }\n"
    "\n"
    "  if (h0) {\n"
    "    if (pxCoords.y > 0.5) {\n"
    "      outColors[0] = d; outColors[1] = c; outColors[2] = c; outColors[3] = d;\n"
    "      finalCoords = vec2(pxCoords.x, 2.0 * (pxCoords.y - 0.5));\n"
    "    } else {\n"
    "      outColors[0] = a; outColors[1] = b; outColors[2] = d; outColors[3] = c;\n"
    "      finalCoords = vec2(pxCoords.x, 2.0 * pxCoords.y);\n"
    "    }\n"
    "  } else if (h1) {\n"
    "    if (pxCoords.y > 0.5) {\n"
    "      outColors[0] = b; outColors[1] = a; outColors[2] = c; outColors[3] = d;\n"
    "      finalCoords = vec2(pxCoords.x, 2.0 * (pxCoords.y - 0.5));\n"
    "    } else {\n"
    "      outColors[0] = a; outColors[1] = b; outColors[2] = b; outColors[3] = a;\n"
    "      finalCoords = vec2(pxCoords.x, 2.0 * pxCoords.y);\n"
    "    }\n"
    "  } else {\n"
    "    outColors[0] = a; outColors[1] = b, outColors[2] = c, outColors[3] = d;\n"
    "    finalCoords = pxCoords;\n"
    "  }\n"
    "\n"
    "  outWeights = vec3(finalCoords.x, finalCoords.x, finalCoords.y);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "  lowp vec3 t5 = texture2D(texture, c5).rgb;\n"
    "  lowp vec3 t6 = texture2D(texture, c6).rgb;\n"
    "  lowp vec3 t9 = texture2D(texture, c9).rgb;\n"
    "  lowp vec3 t10 = texture2D(texture, c10).rgb;\n"
    "\n"
    "  lowp vec4 flagsTexture = floor(texture2D(previousPass, passCoords) * 255.0 + 0.5);\n"
    "  lowp vec3 flags[3];\n"
    "  flags[0] = unpack(flagsTexture.x);\n"
    "  flags[1] = unpack(flagsTexture.y);\n"
    "  flags[2] = unpack(flagsTexture.z);\n"
    "\n"
    "  lowp vec2 pxCoords = fract(screenCoords);\n"
    "\n"
    "  lowp vec3 colors[4];\n"
    "  lowp vec3 weights;\n"
    "\n"
    "  bool triangulate = flags[0].x > 0.0 || flags[0].y > 0.0;\n"
    "  if (triangulate) {\n"
    "    triangleInterpolate(t5, t6, t9, t10, flags, pxCoords, colors, weights);\n"
    "  } else {\n"
    "    quadInterpolate(t5, t6, t9, t10, flags, pxCoords, colors, weights);\n"
    "  }\n"
    "  lowp vec3 final = blend(blend(colors[0], colors[1], weights.x), blend(colors[2], colors[3], weights.y), weights.z);\n"
    "\n"
    "  gl_FragColor = vec4(final, 1.0);\n"
    "}";

ShaderManager::Chain ShaderManager::getShader(const ShaderManager::Config& config) {
    switch (config.type) {
    case Type::SHADER_DEFAULT: {
        return { { { defaultShaderVertex, defaultShaderFragment, true, 1.0 } }, true };
    }

    case Type::SHADER_CRT: {
        return { { { defaultShaderVertex, crtShaderFragment, true, 1.0 } } , true };
    }

    case Type::SHADER_LCD: {
        return { { {defaultShaderVertex, lcdShaderFragment, true, 1.0 } }, true };
    }

    case Type::SHADER_SHARP: {
        return { { { defaultShaderVertex, defaultSharpFragment, true, 1.0 } }, true };
    }

    case Type::SHADER_UPSCALE_CUT: {
        std::string defines = buildDefines(cutUpscaleParams, config.params);
        return { { {
            defines + cutUpscaleVertex,
            defines + cutUpscaleFragment,
            false,
            1.0
        } } , false };
    }

    case Type::SHADER_UPSCALE_CUT2: {
        std::string defines = buildDefines(cut2UpscaleParams, config.params);
        return {
            {
                {
                defines + cut2UpscaleVertex,
                defines + cut2UpscaleFragment,
                false,
                1.0
                }
            },
            false
        };
    }

    case Type::SHADER_UPSCALE_CUT3: {
        std::string defines = buildDefines(cut3UpscaleParams, config.params);
        return {
            {
                {
                    defines + cut3UpscalePass0Vertex,
                    defines + cut3UpscalePass0Fragment,
                    false,
                    1.0
                },
                {
                    defines + cut3UpscalePass1Vertex,
                    defines + cut3UpscalePass1Fragment,
                    false,
                    1.0
                }
            },
            false
        };
    }
}
}

std::string ShaderManager::buildDefines(
    std::unordered_map<std::string, std::string> baseParams,
    std::unordered_map<std::string, std::string> customParams
) {
    customParams.insert(baseParams.begin(), baseParams.end());

    std::string result;
    std::for_each(customParams.begin(), customParams.end(), [&result] (auto param) {
        result += "#define " + param.first + " " + param.second + "\n";
    });

    return result + "\n";
}

bool ShaderManager::Chain::operator==(const ShaderManager::Chain &other) const {
    return this->passes == other.passes && this->linearTexture == other.linearTexture;
}

bool ShaderManager::Chain::operator!=(const ShaderManager::Chain &other) const {
    return !(*this == other);
}

bool ShaderManager::Pass::operator==(const ShaderManager::Pass &other) const {
    return this->linear == other.linear && this->scale == other.scale &&
           this->vertex == other.vertex && this->fragment == other.fragment;
}
} //namespace libretrodroid
